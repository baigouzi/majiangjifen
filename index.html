<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>麻将记分器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- 自定义Tailwind配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        mahjong: {
                            red: '#E63946',
                            green: '#457B9D',
                            yellow: '#F1FAEE',
                            dark: '#1D3557',
                            light: '#A8DADC',
                            neonRed: '#FF2D55',
                            neonGreen: '#34D399',
                            neonBlue: '#38BDF8'
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    boxShadow: {
                        'neon-red': '0 0 5px #FF2D55, 0 0 10px #FF2D55',
                        'neon-green': '0 0 5px #34D399, 0 0 10px #34D399',
                        'neon-blue': '0 0 5px #38BDF8, 0 0 10px #38BDF8',
                        'card': '0 8px 30px rgba(0, 0, 0, 0.12)',
                    }
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
			/* 新增：隐藏滚动条 */
			.scrollbar-hide {
				-ms-overflow-style: none;  /* IE and Edge */
				scrollbar-width: none;  /* Firefox */
			}
			.scrollbar-hide::-webkit-scrollbar {
				display: none;  /* Chrome, Safari, Opera */
			}
            .card-shadow {
                box-shadow: var(--tw-shadow-card);
            }
            .score-change {
                position: relative;
                overflow: hidden;	
            }
            .winner-selected {
                border: 2px solid #34D399;
                background-color: rgba(52, 211, 153, 0.1);
                box-shadow: var(--tw-shadow-neon-green);
            }
            .banker-selected {
                border: 2px solid #FF2D55;
                background-color: rgba(255, 45, 85, 0.1);
                box-shadow: var(--tw-shadow-neon-red);
            }
            .banker-candidate {
                border: 2px dashed #FF2D55;
                background-color: rgba(255, 45, 85, 0.05);
            }
            .winner-candidate {
                border: 2px dashed #34D399;
                background-color: rgba(52, 211, 153, 0.05);
            }
            .edit-input {
                @apply w-[100px] px-2 py-1 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-mahjong-neonBlue/50 text-sm font-medium;
            }
            .total-edit-input {
                @apply w-[50px] px-2 py-1 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-mahjong-neonBlue/50 text-sm font-bold text-right;
            }
            .init-score-input {
                @apply w-full px-2 py-1.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-mahjong-neonBlue/50 text-sm;
            }
            /* 隐藏数字输入框默认的上下箭头 */
            input[type="number"]::-webkit-inner-spin-button,
            input[type="number"]::-webkit-outer-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }
            input[type="number"] {
                -moz-appearance: textfield;
                appearance: textfield;
            }
            .toast {
                @apply fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-mahjong-dark text-white px-4 py-2 rounded-lg text-sm z-50 opacity-95 transition-all duration-300;
            }
            .base-score-container {
                @apply relative;
            }
            .base-score-btn {
                @apply absolute w-6 h-6 flex items-center justify-center text-xs text-gray-600 bg-mahjong-light rounded-full transition-all hover:scale-110;
            }
            .player-nickname-display {
                @apply text-xs font-medium text-mahjong-dark mb-1 block;
            }
            .disabled-btn {
                @apply opacity-50 cursor-not-allowed;
            }
            .gradient-bg {
                background: linear-gradient(135deg, #F1FAEE 0%, #A8DADC 100%);
            }
            .card-gradient {
                background: linear-gradient(180deg, white 0%, #f9fafb 100%);
            }
            .history-table {
                @apply w-full text-sm border-collapse;
            }
            .history-table th {
                @apply py-2 px-1 text-left text-gray-500 font-medium border-b border-gray-100 sticky top-0 bg-white z-10;
            }
            .history-table td {
                @apply py-2 px-1 border-b border-gray-100;
            }
            .history-row-highlight {
                @apply bg-mahjong-light/20;
            }
            /* 矩阵式记分牌样式 - 优化版 */
            .matrix-scoreboard {
                @apply w-full border-collapse text-xs;
            }
            .matrix-scoreboard th {
                @apply py-1 px-1 text-center bg-mahjong-dark/5 font-medium text-gray-600 border border-gray-100;
                white-space: nowrap; /* 防止表头换行 */
                font-size: 0.75rem; /* 进一步缩小表头字体 */
            }
            .matrix-scoreboard td {
                @apply py-1 px-0.5 text-center border border-gray-100;
                font-size: 0.7rem; /* 缩小单元格字体 */
            }
            .matrix-scoreboard .round-col {
                @apply bg-mahjong-light/10 font-medium w-[50px]; /* 缩小局数列宽度 */
            }
            .matrix-scoreboard .total-row {
                @apply bg-mahjong-dark/10 font-bold;
            }
            .score-positive {
                @apply text-green-600 font-medium;
            }
            .score-negative {
                @apply text-red-600 font-medium;
            }
            .score-zero {
                @apply text-gray-400;
            }
            .init-adjust-row {
                @apply bg-blue-50/50;
            }
            .init-adjust-cell {
                @apply text-blue-600 font-medium;
            }
            /* 备注列样式优化 */
            .note-col {
                @apply w-[70px] max-w-[70px] px-1; /* 缩小备注列宽度 */
                word-break: break-all; /* 强制换行 */
                white-space: normal; /* 允许换行 */
                line-height: 1.2; /* 缩小行高 */
            }
            .note-text {
                @apply text-xs text-gray-500 leading-tight; /* 更小的字体和紧凑行高 */
                display: block; /* 强制分行显示 */
            }
            /* 统一玩家卡片按钮和徽章样式 */
            /* 基础徽章和按钮样式 */
            .banker-badge:not(.hidden),
            .winner-badge:not(.hidden),
            .action-btn:not(.hidden) {
                @apply text-xs font-medium px-2 py-0.5 rounded-full transition-all duration-200;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                min-width: 40px;
                height: 20px;
                line-height: 20px;
                box-sizing: border-box;
            }
            
            /* 庄家相关 - 红色系 */
            .banker-badge {
                @apply bg-mahjong-neonRed text-white shadow-neon-red;
            }
            
            /* 当庄家徽章单独显示时，向右移动 */
            .badge-area .banker-badge:not(.hidden) + .winner-badge.hidden {
                margin-left: 0.5rem; /* 向右移动2个单位（1rem约等于2个Tailwind单位） */
            }
            
            .banker-btn {
                @apply bg-mahjong-red text-white shadow-md hover:bg-mahjong-neonRed;
            }
            
            /* 胡牌相关 - 绿色系 */
            .winner-badge {
                @apply bg-mahjong-neonGreen text-white shadow-neon-green;
                margin-left: -0.5rem; /* 向左移动0.5rem */
            }
            
            .winner-btn {
                @apply bg-mahjong-green text-white shadow-md hover:bg-mahjong-neonGreen;
            }
            
            /* 操作容器样式 */
            .action-container {
                @apply flex items-center gap-2;
            }
        }
    </style>
</head>
<body class="gradient-bg min-h-screen">
    <div class="container mx-auto px-4 py-6 max-w-lg">
        <!-- 提示消息组件 -->
        <div id="toast" class="toast hidden">操作成功</div>
        
        <!-- 标题区域 -->
        <header class="text-center mb-8 relative">
            <div class="absolute inset-0 bg-mahjong-dark/5 blur-md rounded-xl -z-10"></div>
            <h1 class="text-[clamp(1.8rem,4vw,2.8rem)] font-bold text-mahjong-dark mb-3 relative">
                <i class="fa fa-trophy text-mahjong-neonRed mr-2"></i>麻将记分器
                <span class="absolute -bottom-1 left-1/2 transform -translate-x-1/2 w-2/3 h-1 bg-gradient-to-r from-mahjong-neonRed to-mahjong-neonGreen rounded-full"></span>
            </h1>
            <p class="text-gray-600 text-sm bg-white/70 px-4 py-2 rounded-full inline-block backdrop-blur-sm">
                庄闲倍率生效 | 闲闲胡牌倍率1
            </p>
        </header>

        <!-- 主内容区 -->
        <main class="card-gradient rounded-2xl p-6 card-shadow border border-gray-100">            
            <!-- 本局结果区域 -->
            <div class="mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-semibold text-mahjong-dark border-b border-gray-100 pb-3 text-left flex justify-between items-center w-full">
                        <div>
                            <i class="fa fa-bar-chart text-mahjong-neonGreen mr-2 text-sm"></i>
                            实时分数
                        </div>
                                        
                    <!-- 基础分数 -->
                    <div class="w-[120px]">
                        <div class="base-score-container">
                            <div class="absolute top-[-20px] left-0 right-0 text-center text-xs text-gray-500">本局倍率</div>
                            <input type="number" id="base-score" value="1" min="1" 
                                   class="w-full px-4 py-2 border border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-mahjong-neonBlue/50 focus:border-transparent text-sm pl-8 pr-8 bg-white text-center">
                            <!-- 增减按钮保留 -->
                            <button id="base-score-decrease" class="base-score-btn top-1/2 -translate-y-1/2 left-2 bg-white shadow-sm">
                                <i class="fa fa-minus"></i>
                            </button>
                            <button id="base-score-increase" class="base-score-btn top-1/2 -translate-y-1/2 right-2 bg-white shadow-sm">
                                <i class="fa fa-plus"></i>
                            </button>
                        </div>
                    </div>
                    </h2>
                </div>
                
                <div class="space-y-3 mb-6">
                    <!-- 玩家信息卡片（使用统一结构减少冗余） -->
                    <div class="score-change bg-white/80 p-3 rounded-xl flex justify-between items-center cursor-pointer hover:bg-white/90 transition-all duration-200" data-player="player1">
                        <span class="font-medium player-name edit-trigger inline-block w-[90px] text-left overflow-hidden whitespace-nowrap" id="display-name1" data-player="player1">玩家1</span>
                        <div class="flex items-center gap-2">
                            <div class="badge-area grid grid-cols-2 w-[40px] text-right">
                                <span class="banker-badge hidden text-xs">庄</span>
                                <span class="winner-badge hidden text-xs">胡</span>
                            </div>

                            <!-- 操作按钮容器 -->
                            <div class="action-container hidden">
                                <button class="action-btn banker-btn hidden text-xs px-1">上庄</button>
                                <button class="action-btn winner-btn hidden text-xs px-1">胡</button>
                            </div>
                            <!-- 本局分数 -->
                            <div class="text-right min-w-[60px]">
                                <div class="text-xs text-gray-500">本局</div>
                                <span id="player1-score" class="text-mahjong-dark block text-right text-base font-medium">0</span>
                            </div>
                            <!-- 累计总分 -->
                            <div class="text-right min-w-[60px] border-l border-gray-100 pl-2">
                                <div class="text-xs text-gray-500">总分</div>
                                <span id="player1-total" class="font-bold text-mahjong-neonGreen block text-right text-base transition-all" data-player="player1">0</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="score-change bg-white/80 p-3 rounded-xl flex justify-between items-center cursor-pointer hover:bg-white/90 transition-all duration-200" data-player="player2">
                        <span class="font-medium player-name edit-trigger inline-block w-[90px] text-left overflow-hidden whitespace-nowrap" id="display-name2" data-player="player2">玩家2</span>
                        <div class="flex items-center gap-2">
                            <div class="badge-area grid grid-cols-2 w-[40px] text-right">
                                <span class="banker-badge hidden text-xs">庄</span>
                                <span class="winner-badge hidden text-xs">胡</span>
                            </div>
                            <!-- 操作按钮容器 -->
                            <div class="action-container hidden">
                                <button class="action-btn banker-btn hidden text-xs px-1">上庄</button>
                                <button class="action-btn winner-btn hidden text-xs px-1">胡</button>
                            </div>
                            <div class="text-right min-w-[60px]">
                                <div class="text-xs text-gray-500">本局</div>
                                <span id="player2-score" class="text-mahjong-dark block text-right text-base font-medium">0</span>
                        </div>
                        <!-- 累计总分 -->
                        <div class="text-right min-w-[60px] border-l border-gray-100 pl-2">
                            <div class="text-xs text-gray-500">总分</div>
                            <span id="player2-total" class="font-bold text-mahjong-neonGreen block text-right text-base transition-all" data-player="player2">0</span>
                        </div>
                        </div>
                    </div>
                    
                    <div class="score-change bg-white/80 p-3 rounded-xl flex justify-between items-center cursor-pointer hover:bg-white/90 transition-all duration-200" data-player="player3">
                        <span class="font-medium player-name edit-trigger inline-block w-[90px] text-left overflow-hidden whitespace-nowrap" id="display-name3" data-player="player3">玩家3</span>
                        <div class="flex items-center gap-2">
                            <div class="badge-area grid grid-cols-2 w-[40px] text-right">
                                <span class="banker-badge hidden text-xs">庄</span>
                                <span class="winner-badge hidden text-xs">胡</span>
                            </div>
                            <!-- 操作按钮容器 -->
                            <div class="action-container hidden">
                                <button class="action-btn banker-btn hidden text-xs px-1">上庄</button>
                                <button class="action-btn winner-btn hidden text-xs px-1">胡</button>
                            </div>
                            <div class="text-right min-w-[60px]">
                                <div class="text-xs text-gray-500">本局</div>
                                <span id="player3-score" class="text-mahjong-dark block text-right text-base font-medium">0</span>
                            </div>
                            <!-- 累计总分 -->
                            <div class="text-right min-w-[60px] border-l border-gray-100 pl-2">
                                <div class="text-xs text-gray-500">总分</div>
                                <span id="player3-total" class="font-bold text-mahjong-neonGreen block text-right text-base transition-all" data-player="player3">0</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="score-change bg-white/80 p-3 rounded-xl flex justify-between items-center cursor-pointer hover:bg-white/90 transition-all duration-200" data-player="player4">
                        <span class="font-medium player-name edit-trigger inline-block w-[90px] text-left overflow-hidden whitespace-nowrap" id="display-name4" data-player="player4">玩家4</span>
                        <div class="flex items-center gap-2">
                            <div class="badge-area grid grid-cols-2 w-[40px] text-right">
                                <span class="banker-badge hidden text-xs">庄</span>
                                <span class="winner-badge hidden text-xs">胡</span>
                            </div>
                            <!-- 操作按钮容器 -->
                            <div class="action-container hidden">
                                <button class="action-btn banker-btn hidden text-xs px-1">上庄</button>
                                <button class="action-btn winner-btn hidden text-xs px-1">胡</button>
                            </div>
                            <div class="text-right min-w-[60px]">
                                <div class="text-xs text-gray-500">本局</div>
                                <span id="player4-score" class="text-mahjong-dark block text-right text-base font-medium">0</span>
                            </div>
                            <!-- 累计总分 -->
                            <div class="text-right min-w-[60px] border-l border-gray-100 pl-2">
                                <div class="text-xs text-gray-500">总分</div>
                                <span id="player4-total" class="font-bold text-mahjong-neonGreen block text-right text-base transition-all" data-player="player4">0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 历史记录按钮 -->
                <button id="history-btn" class="w-full bg-gradient-to-r from-mahjong-green to-mahjong-neonGreen text-white py-2 rounded-xl text-sm font-medium shadow-lg shadow-mahjong-green/20 hover:opacity-90 transition-all">
                    <i class="fa fa-history mr-2"></i>计分板
                </button>
            </div>
            
            <!-- 游戏设置区域（简化版） -->
            <div class="mb-8">
                <div class="space-y-4">
                    <!-- 合并行：庄家倍率 + 重置总分 + 重置庄家 -->
                    <div class="grid grid-cols-12 gap-4">
                        <!-- 庄家倍率下拉 -->
                        <div class="col-span-4">
                            <select id="multiplier-select" class="w-full bg-mahjong-light border border-mahjong-light text-white py-2 rounded-xl text-sm focus:outline-none focus:ring-2 focus:ring-mahjong-neonGreen/50 focus:border-transparent">
                                <option value="1">1倍 (庄闲生效)</option>
								<option value="2">2倍 (庄闲生效)</option>
                                <option value="4">4倍 (庄闲生效)</option>
                                <option value="8" selected>8倍 (庄闲生效)</option>
                            </select>
                            <input type="hidden" id="selected-multiplier" value="8">
                        </div>
                        
                        <!-- 重置按钮组 -->
                        <div class="col-span-4">
                            <button id="reset-total-btn" class="w-full bg-gradient-to-r from-gray-500 to-gray-600 text-white py-2 rounded-xl text-sm font-medium hover:opacity-90 transition-all">
                                <i class="fa fa-refresh mr-2"></i>重置总分
                            </button>
                        </div>
                        
                        <div class="col-span-4">
                            <button id="reset-banker-btn" class="w-full bg-gradient-to-r from-gray-400 to-gray-500 text-white py-2 rounded-xl text-sm font-medium hover:opacity-90 transition-all">
                                <i class="fa fa-star mr-2"></i>重置庄家
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 单独的分数调整区域 -->
            <div class="mb-8">
                <div class="p-4 bg-white/50 rounded-xl border border-gray-100">
                    <div class="grid grid-cols-12 gap-4 mb-3">
                        <!-- 选择调整对象 -->
                        <div class="col-span-4">
                            <label class="block text-gray-700 font-medium text-sm mb-1.5">调整对象</label>
                            <select id="score-adjust-target" class="w-full bg-white border border-gray-200 text-gray-700 py-2 rounded-xl text-sm focus:outline-none focus:ring-2 focus:ring-mahjong-neonBlue/50 focus:border-transparent">
                                <option value="all">全体玩家</option>
                                <option value="player1">玩家1</option>
                                <option value="player2">玩家2</option>
                                <option value="player3">玩家3</option>
                                <option value="player4">玩家4</option>
                            </select>
                        </div>
                        
                        <!-- 输入调整分数 -->
                        <div class="col-span-5">
                            <label class="block text-gray-700 font-medium text-sm mb-1.5">调整分数</label>
                            <input type="number" id="score-adjust-value" value="0" 
                                   class="init-score-input" placeholder="输入调整分数">
                        </div>
                        
                        <!-- 调整按钮 -->
                        <div class="col-span-3 flex items-end">
                            <button id="apply-adjust-btn" class="w-full bg-gradient-to-r from-mahjong-dark to-gray-700 text-white py-2 rounded-xl text-sm font-medium hover:opacity-90 transition-all">
                                <i class="fa fa-check"></i>
                            </button>
                        </div>
                    </div>
                    
                    <p class="text-xs text-gray-500 mt-2 italic">
                        注：正数为加分，负数为减分，此操作会记录到历史记录中
                    </p>
                </div>
            </div>


        </main>
        
        <!-- 历史记录模态框 - 矩阵式记分牌 -->
        <div id="history-modal" class="fixed inset-0 bg-black/60 flex items-center justify-center z-50 hidden backdrop-blur-sm">
            <div class="bg-white rounded-2xl p-6 max-w-sm w-full mx-4 max-h-[80vh] overflow-y-auto shadow-2xl scrollbar-hide" id="modal-content">
                <div class="flex justify-between items-center mb-4 pb-2 border-b border-gray-100">
                    <h3 class="text-lg font-semibold text-mahjong-dark flex items-center">
                        <i class="fa fa-history text-mahjong-neonBlue mr-2"></i>计分板
                    </h3>
                    <button id="close-modal" class="text-gray-500 p-1 rounded-full">
                        <i class="fa fa-times text-lg"></i>
                    </button>
                </div>
                
                <!-- 矩阵式记分牌 -->
                <div id="history-list" class="mb-4">
                    <div id="history-records-container">
                        <p class="text-gray-500 text-center italic py-8">暂无记录</p>
                    </div>
                </div>
                
                <div class="flex gap-2 mt-2">
                    <button id="clear-history" class="flex-1 text-mahjong-neonRed border border-mahjong-neonRed/20 rounded-xl py-2 text-sm font-medium hover:bg-mahjong-neonRed/5 transition-all">
                        清空记录
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 页脚 -->
        <footer class="mt-8 text-center text-gray-500 text-xs bg-white/70 p-4 rounded-xl backdrop-blur-sm">
            <p class="flex flex-wrap justify-center gap-2">
                <span>麻将记分器 © 2025</span>
                <span>|</span>
                <span>点击玩家选择庄家/胡牌</span>
                <span>|</span>
                <span>庄闲倍率规则</span>
                <span>|</span>
                <span>闲闲胡牌1倍</span>
                <span>|</span>
                <span>基础分仅支持2的次幂值</span>
                <span>|</span>
                <span>总分支持手动编辑</span>
                <span>|</span>
                <span>初始分支持累加模式</span>
            </p>
        </footer>
    </div>

    <script>
        // 初始化变量
        let historyRecords = [];
        let selectedMultiplier = 8; // 默认倍率改为8倍
        let currentBanker = ''; // 当前庄家
        let playerNicknames = {
            player1: "玩家1",
            player2: "玩家2",
            player3: "玩家3",
            player4: "玩家4"
        };
        let playerTotalScores = {
            player1: 0,
            player2: 0,
            player3: 0,
            player4: 0
        };
        let currentRoundScores = {
            player1: 0,
            player2: 0,
            player3: 0,
            player4: 0
        };
        let selectedWinner = null; // 胡牌玩家
        let isEditing = false; // 防止同时编辑多个昵称/总分
        let activePlayerCard = null; // 当前激活的玩家卡片
        // 2的次幂基础分值列表
        const powerOfTwoValues = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512];
        // 记录当前局数（包含初始分调整记录）
        let currentRoundNumber = 0;
        
        // DOM元素
        const baseScoreInput = document.getElementById('base-score');
        const baseScoreDecrease = document.getElementById('base-score-decrease');
        const baseScoreIncrease = document.getElementById('base-score-increase');
        const multiplierSelect = document.getElementById('multiplier-select');
        const selectedMultiplierInput = document.getElementById('selected-multiplier');
        const resetTotalBtn = document.getElementById('reset-total-btn');
        const resetBankerBtn = document.getElementById('reset-banker-btn');
        const toast = document.getElementById('toast');
        
        // 分数调整相关元素
        const scoreAdjustTarget = document.getElementById('score-adjust-target');
        const scoreAdjustValue = document.getElementById('score-adjust-value');
        const applyAdjustBtn = document.getElementById('apply-adjust-btn');
        
        // 分数元素
        const playerScores = {
            player1: document.getElementById('player1-score'),
            player2: document.getElementById('player2-score'),
            player3: document.getElementById('player3-score'),
            player4: document.getElementById('player4-score')
        };
        const playerTotals = {
            player1: document.getElementById('player1-total'),
            player2: document.getElementById('player2-total'),
            player3: document.getElementById('player3-total'),
            player4: document.getElementById('player4-total')
        };
        
        // 昵称元素
        const displayNames = {
            player1: document.getElementById('display-name1'),
            player2: document.getElementById('display-name2'),
            player3: document.getElementById('display-name3'),
            player4: document.getElementById('display-name4')
        };
        const editTriggers = document.querySelectorAll('.edit-trigger');
        
        // 结果区元素
        const playerCards = document.querySelectorAll('.score-change[data-player]');
        const winnerBadges = document.querySelectorAll('.winner-badge');
        const bankerBadges = document.querySelectorAll('.banker-badge');
        
        // 历史记录元素
        const historyBtn = document.getElementById('history-btn');
        const historyModal = document.getElementById('history-modal');
        const modalContent = document.getElementById('modal-content');
        const closeModal = document.getElementById('close-modal');
        const historyList = document.getElementById('history-list');
        const historyRecordsContainer = document.getElementById('history-records-container');
        const clearHistoryBtn = document.getElementById('clear-history');
        
        // 显示提示消息
        function showToast(message, duration = 2000) {
            toast.textContent = message;
            toast.classList.remove('hidden');
            
            setTimeout(() => {
                toast.classList.add('hidden');
            }, duration);
        }
        
        function hideAllActionButtons() {
    playerCards.forEach(card => {
        const actionContainer = card.querySelector('.action-container');
        if (actionContainer) {
            actionContainer.classList.add('hidden');
            // 隐藏具体按钮
            const bankerBtn = actionContainer.querySelector('.banker-btn');
            const winnerBtn = actionContainer.querySelector('.winner-btn');
            if (bankerBtn) bankerBtn.classList.add('hidden');
            if (winnerBtn) winnerBtn.classList.add('hidden');
        }
        // 移除候选样式
        card.classList.remove('banker-candidate', 'winner-candidate');
    });
    activePlayerCard = null;
}
        
        // 更新玩家卡片状态
        function updatePlayerCardState() {
            playerCards.forEach(card => {
                const player = card.getAttribute('data-player');
                const bankerBadge = card.querySelector('.banker-badge');
                const winnerBadge = card.querySelector('.winner-badge');
                
                // 更新庄家徽章
                if (currentBanker === player) {
                    bankerBadge.classList.remove('hidden');
                    card.classList.add('banker-selected');
                } else {
                    bankerBadge.classList.add('hidden');
                    card.classList.remove('banker-selected');
                }
                
                // 更新胡牌徽章
                if (selectedWinner === player) {
                    winnerBadge.classList.remove('hidden');
                    card.classList.add('winner-selected');
                } else {
                    winnerBadge.classList.add('hidden');
                    card.classList.remove('winner-selected');
                }
            });
        }
        
        // 设置基础分值（自动修正为合法值）
        function setBaseScore(value) {
            let validValue = value;
            if (!powerOfTwoValues.includes(validValue)) {
                validValue = powerOfTwoValues.reduce((prev, curr) => {
                    return curr <= validValue ? curr : prev;
                }, 1);
                showToast(`基础分自动修正为${validValue}（仅支持2的次幂值）`);
            }
            baseScoreInput.value = validValue;
        }
        
        // 更新所有玩家名称显示
        function updateAllPlayerNames() {
            // 更新结果区域显示名称
            Object.keys(displayNames).forEach(player => {
                displayNames[player].textContent = playerNicknames[player];
            });
            
            // 更新分数调整下拉框选项文字
            Object.keys(playerNicknames).forEach(player => {
                const option = scoreAdjustTarget.querySelector(`option[value="${player}"]`);
                if (option) option.textContent = playerNicknames[player];
            });
            
            // 更新历史记录
            updateHistoryList();
        }
        
        // 应用分数调整
        async function applyScoreAdjustment() {
            const target = scoreAdjustTarget.value;
            const value = parseInt(scoreAdjustValue.value) || 0;
            
            if (value === 0) {
                showToast('请输入调整分数');
                return;
            }
            
            // 创建调整记录
            const adjustmentRecord = {
                type: 'adjustment',
                round: currentRoundNumber + 1,
                scores: {},
                banker: currentBanker,
                winner: null,
                timestamp: new Date().toLocaleString(),
                adjustment: { target, value }
            };
            
            // 应用调整
            if (target === 'all') {
                // 全体调整
                Object.keys(playerTotalScores).forEach(player => {
                    playerTotalScores[player] += value;
                    adjustmentRecord.scores[player] = value;
                });
                showToast(`已为所有玩家${value > 0 ? '加' : '减'}${Math.abs(value)}分`);
            } else {
                // 单独调整
                playerTotalScores[target] += value;
                adjustmentRecord.scores[target] = value;
                
                // 其他玩家分数不变
                Object.keys(playerTotalScores).forEach(player => {
                    if (player !== target) {
                        adjustmentRecord.scores[player] = 0;
                    }
                });
                
                showToast(`已为${playerNicknames[target]}${value > 0 ? '加' : '减'}${Math.abs(value)}分`);
            }
            
            // 更新显示
            updateTotalScoresDisplay();
            
            // 保存到历史记录
            historyRecords.push(adjustmentRecord);
            currentRoundNumber++;
            
            // 保存数据
            await saveTotalScoresToStorage();
            await kvStorage.set('mahjongHistory', historyRecords);
            
            // 更新历史记录显示
            updateHistoryList();
            
            // 清空输入框
            scoreAdjustValue.value = 0;
        }
        
        // 计算并保存得分
        async function calculateAndSaveScores() {
            if (!currentBanker || !selectedWinner) {
                showToast('请先设置庄家和胡牌者');
                return false;
            }
            
            // 获取基础分和倍率
            const baseScore = parseInt(baseScoreInput.value) || 1;
            const multiplier = selectedMultiplier;
            
            // 计算得分
            const scores = {};
            
            // 计算胡牌者得分
            if (currentBanker === selectedWinner) {
                // 庄家胡牌：每个闲家输 baseScore * multiplier
                scores[selectedWinner] = baseScore * multiplier * 3;
                Object.keys(playerTotalScores).forEach(player => {
                    if (player !== selectedWinner) {
                        scores[player] = -baseScore * multiplier;
                    }
                });
            } else {
                // 闲家胡牌：庄家输 baseScore * multiplier，其他闲家输 baseScore
                scores[selectedWinner] = baseScore * multiplier + baseScore * 2;
                scores[currentBanker] = -baseScore * multiplier;
                
                Object.keys(playerTotalScores).forEach(player => {
                    if (player !== selectedWinner && player !== currentBanker) {
                        scores[player] = -baseScore;
                    }
                });
            }
            
            // 更新本局分数存储和显示
            currentRoundScores = scores;
            Object.keys(scores).forEach(player => {
                playerScores[player].textContent = scores[player];
                playerScores[player].classList.remove('score-positive', 'score-negative', 'score-zero');
                if (scores[player] > 0) {
                    playerScores[player].classList.add('score-positive');
                } else if (scores[player] < 0) {
                    playerScores[player].classList.add('score-negative');
                } else {
                    playerScores[player].classList.add('score-zero');
                }
            });
            
            // 更新总分
            Object.keys(scores).forEach(player => {
                playerTotalScores[player] += scores[player];
            });
            updateTotalScoresDisplay();
            
            // 记录本局结果到历史
            currentRoundNumber++;
            const roundRecord = {
                type: 'round',
                round: currentRoundNumber,
                scores: scores,
                banker: currentBanker,
                winner: selectedWinner,
                baseScore: baseScore,
                multiplier: multiplier,
                timestamp: new Date().toLocaleString()
            };
            historyRecords.push(roundRecord);
            
            // 胡牌者成为新的庄家
            currentBanker = selectedWinner;
            
            // 清除当前胡牌选择
            selectedWinner = null;
            
            // 保存数据
            await saveTotalScoresToStorage();
            await saveBankerToStorage();
            await kvStorage.set('mahjongHistory', historyRecords);
            
            // 更新显示
            updatePlayerCardState();
            updateHistoryList();
            
            // 隐藏操作按钮
            hideAllActionButtons();
            

            
            showToast('分数计算完成，已记录本局结果');
            return true;
        }
        






        // 全局kvStorage实例
        let kvStorage = null;

        // 从存储加载数据
        async function loadFromStorage() {
            // 加载昵称
            const savedNicknames = await kvStorage.get('mahjongNicknames');
            if (savedNicknames) {
                playerNicknames = savedNicknames;
                updateAllPlayerNames();
            }
            
            // 加载总分
            const savedTotals = await kvStorage.get('mahjongTotalScores');
            if (savedTotals) {
                playerTotalScores = savedTotals;
                updateTotalScoresDisplay();
            }
            
            // 加载本局分数
            const savedCurrentRoundScores = await kvStorage.get('mahjongCurrentRoundScores');
            if (savedCurrentRoundScores) {
                currentRoundScores = savedCurrentRoundScores;
                // 更新本局分数显示
                Object.keys(currentRoundScores).forEach(player => {
                    if (playerScores[player]) {
                        playerScores[player].textContent = currentRoundScores[player];
                        playerScores[player].classList.remove('score-positive', 'score-negative', 'score-zero');
                        if (currentRoundScores[player] > 0) {
                            playerScores[player].classList.add('score-positive');
                        } else if (currentRoundScores[player] < 0) {
                            playerScores[player].classList.add('score-negative');
                        } else {
                            playerScores[player].classList.add('score-zero');
                        }
                    }
                });
            }
            
            // 加载历史记录
            const savedHistory = await kvStorage.get('mahjongHistory');
            if (savedHistory) {
                historyRecords = savedHistory;
                currentRoundNumber = historyRecords.length;
                updateHistoryList();
            }
            
            // 加载庄家状态
            const savedBanker = await kvStorage.get('mahjongCurrentBanker');
            if (savedBanker) {
                currentBanker = savedBanker;
                updatePlayerCardState();
            }
            
            // 加载倍率状态
            const savedMultiplier = await kvStorage.get('mahjongMultiplier');
            if (savedMultiplier) {
                selectedMultiplier = parseInt(savedMultiplier);
                multiplierSelect.value = selectedMultiplier;
                selectedMultiplierInput.value = selectedMultiplier;
            }
            
            // 初始化基础分输入框
            setBaseScore(parseInt(baseScoreInput.value) || 1);
        }
        
        // 保存庄家状态
        async function saveBankerToStorage() {
            await kvStorage.set('mahjongCurrentBanker', currentBanker);
        }
        
        // 保存倍率状态
        async function saveMultiplierToStorage() {
            await kvStorage.set('mahjongMultiplier', selectedMultiplier);
        }
        
        // 保存总分到存储
        async function saveTotalScoresToStorage() {
            await kvStorage.set('mahjongTotalScores', playerTotalScores);
            await kvStorage.set('mahjongCurrentRoundScores', currentRoundScores);
        }
        
        // 更新总分显示
        function updateTotalScoresDisplay() {
            Object.keys(playerTotals).forEach(player => {
                const total = playerTotalScores[player];
                playerTotals[player].textContent = total;
                playerTotals[player].classList.remove('text-green-600', 'text-red-600', 'text-mahjong-neonGreen');
                if (total > 0) {
                    playerTotals[player].classList.add('text-green-600', 'text-mahjong-neonGreen');
                } else if (total < 0) {
                    playerTotals[player].classList.add('text-red-600');
                } else {
                    playerTotals[player].classList.add('text-mahjong-neonGreen');
                }
            });
        }
        
        // 重置总分
        async function resetTotalScores() {
            // 记录重置操作到历史
            const resetRecord = {
                type: 'reset',
                round: currentRoundNumber + 1,
                scores: {
                    player1: -playerTotalScores.player1,
                    player2: -playerTotalScores.player2,
                    player3: -playerTotalScores.player3,
                    player4: -playerTotalScores.player4
                },
                timestamp: new Date().toLocaleString()
            };
            historyRecords.push(resetRecord);
            currentRoundNumber++;
            
            // 重置总分
            playerTotalScores = {
                player1: 0,
                player2: 0,
                player3: 0,
                player4: 0
            };
            updateTotalScoresDisplay();
            
            // 重置本局分数
            currentRoundScores = {
                player1: 0,
                player2: 0,
                player3: 0,
                player4: 0
            };
            Object.keys(playerScores).forEach(player => {
                playerScores[player].textContent = '0';
                playerScores[player].classList.remove('score-positive', 'score-negative', 'score-zero');
                playerScores[player].classList.add('score-zero');
            });
            
            // 保存数据
            await saveTotalScoresToStorage();
            await kvStorage.set('mahjongHistory', historyRecords);
            updateHistoryList();
            
            // 隐藏操作按钮
            hideAllActionButtons();
            

            
            showToast('所有玩家总分已重置为0');
        }
        
        // 重置庄家
        async function resetBanker() {
            currentBanker = '';
            selectedWinner = null;
            updatePlayerCardState();
            await saveBankerToStorage();
            
            // 隐藏操作按钮
            hideAllActionButtons();
            

            
            showToast('庄家已重置，请重新选择');
        }
        
        // 事件监听器 - 基础分增减
        baseScoreDecrease.addEventListener('click', () => {
            const currentValue = parseInt(baseScoreInput.value) || 1;
            const currentIndex = powerOfTwoValues.indexOf(currentValue);
            if (currentIndex > 0) {
                baseScoreInput.value = powerOfTwoValues[currentIndex - 1];
            }
        });
        
        baseScoreIncrease.addEventListener('click', () => {
            const currentValue = parseInt(baseScoreInput.value) || 1;
            const currentIndex = powerOfTwoValues.indexOf(currentValue);
            if (currentIndex < powerOfTwoValues.length - 1) {
                baseScoreInput.value = powerOfTwoValues[currentIndex + 1];
            } else {
                const nextValue = powerOfTwoValues[currentIndex] * 2;
                powerOfTwoValues.push(nextValue);
                baseScoreInput.value = nextValue;
            }
        });
        
        baseScoreInput.addEventListener('change', () => {
            setBaseScore(parseInt(baseScoreInput.value) || 1);
        });
        
        // 事件监听器 - 倍率选择
        multiplierSelect.addEventListener('change', async () => {
            selectedMultiplier = parseInt(multiplierSelect.value);
            selectedMultiplierInput.value = selectedMultiplier;
            await saveMultiplierToStorage();
        });
        
        // 事件监听器 - 玩家卡片点击
        playerCards.forEach(card => {
            // 预先获取常用元素以提高性能
            const player = card.getAttribute('data-player');
            const actionContainer = card.querySelector('.action-container');
            const bankerBtn = actionContainer?.querySelector('.banker-btn');
            const winnerBtn = actionContainer?.querySelector('.winner-btn');
            
            card.addEventListener('click', (e) => {
                // 阻止事件冒泡到按钮
                if (e.target.closest('.action-btn')) {
                    return;
                }
                
                // 阻止昵称编辑区域的点击
                if (e.target.classList.contains('player-name') || e.target.closest('.edit-input')) {
                    return;
                }
                
                // 如果点击的是已激活的卡片，则隐藏按钮
                if (activePlayerCard === card) {
                    hideAllActionButtons();
                    return;
                }
                
                // 隐藏其他卡片的按钮
                hideAllActionButtons();
                
                // 显示当前卡片的按钮
                if (actionContainer) {
                    actionContainer.classList.remove('hidden');
                    activePlayerCard = card;
                    
                    // 根据是否有庄家显示不同的按钮
                    if (bankerBtn && winnerBtn) {
                        if (!currentBanker) {
                            // 没有庄家时，只显示"上庄"按钮
                            bankerBtn.classList.remove('hidden');
                            winnerBtn.classList.add('hidden');
                            card.classList.add('banker-candidate');
                        } else {
                            // 有庄家时，只显示"胡"按钮
                            bankerBtn.classList.add('hidden');
                            winnerBtn.classList.remove('hidden');
                            card.classList.add('winner-candidate');
                        }
                    }
                }
            });
        });
        
        // 事件监听器 - 上庄按钮点击
        document.addEventListener('click', async (e) => {
            const bankerBtn = e.target.closest('.banker-btn');
            if (bankerBtn) {
                e.stopPropagation();
                const card = bankerBtn.closest('.score-change');
                const player = card.getAttribute('data-player');
                
                // 设置庄家
                currentBanker = player;
                updatePlayerCardState();
                await saveBankerToStorage();
                

                
                // 隐藏操作按钮
                hideAllActionButtons();
                
                showToast(`${playerNicknames[player]} 成为庄家`);
            }
        });
        
        // 事件监听器 - 胡按钮点击
        document.addEventListener('click', async (e) => {
            const winnerBtn = e.target.closest('.winner-btn');
            if (winnerBtn) {
                e.stopPropagation();
                const card = winnerBtn.closest('.score-change');
                const player = card.getAttribute('data-player');
                
                // 设置胡牌者
                selectedWinner = player;
                
                // 计算并保存得分
                if (await calculateAndSaveScores()) {
                    // 成功计算得分，按钮已隐藏
                } else {
                    // 计算失败，保持按钮显示
                    card.classList.add('winner-candidate');
                }
            }
        });
        
        // 事件监听器 - 重置总分按钮
        resetTotalBtn.addEventListener('click', async () => {
            if (confirm('确定要重置所有玩家的总分吗？此操作不可撤销！')) {
                await resetTotalScores();
            }
        });
        
        // 事件监听器 - 重置庄家按钮
        resetBankerBtn.addEventListener('click', async () => {
            await resetBanker();
        });
        
        // 事件监听器 - 编辑玩家昵称
        // 优化玩家名称编辑功能
        editTriggers.forEach(trigger => {
            trigger.addEventListener('click', (e) => {
                // 只处理玩家名称区域的点击
                if (trigger.classList.contains('player-name')) {
                    e.stopPropagation(); // 阻止事件冒泡到卡片
                    
                    if (isEditing) return; // 防止同时编辑多个昵称
                    isEditing = true;
                    
                    const player = trigger.getAttribute('data-player');
                    const currentName = playerNicknames[player];
                    const playerNumber = player.replace('player', '');
                    
                    // 创建输入框
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = currentName;
                    input.className = 'edit-input';
                    input.maxLength = 10; // 最大字符数，考虑中文输入
                    input.setAttribute('data-player', player);
                    
                    // 替换显示元素为输入框
                    const parent = trigger.parentNode;
                    parent.insertBefore(input, trigger);
                    parent.removeChild(trigger);
                    
                    // 聚焦并选中输入框内容
                    input.focus();
                    input.select();
                    
                    // 完成编辑的处理函数
                    const finishEditing = async (save = true) => {
                        // 检查输入框是否仍然存在于DOM中，防止重复调用
                        if (!parent.contains(input)) {
                            return;
                        }
                        
                        // 移除事件监听器，防止重复触发
                        input.removeEventListener('blur', blurHandler);
                        input.removeEventListener('keydown', keydownHandler);
                        
                        let newName = currentName; // 默认保持原名称
                        
                        if (save) {
                            // 获取新名称（为空则使用默认名称）
                            let tempName = input.value.trim() || `玩家${playerNumber}`;
                            
                            // 限制为5个汉字长度
                            // 使用正则表达式匹配中文
                            const chineseRegex = /[\u4e00-\u9fa5]/g;
                            const chineseMatches = tempName.match(chineseRegex);
                            const chineseCount = chineseMatches ? chineseMatches.length : 0;
                            
                            if (chineseCount > 5) {
                                // 如果中文超过5个，截取前5个中文
                                tempName = tempName.replace(chineseRegex, (match, offset, string) => {
                                    let count = 0;
                                    for (let i = 0; i < offset; i++) {
                                        if (/[\u4e00-\u9fa5]/.test(string[i])) {
                                            count++;
                                        }
                                    }
                                    return count < 5 ? match : '';
                                }).trim();
                            } else if (chineseCount + (tempName.length - chineseCount) > 5) {
                                // 如果中英文混合，总长度超过5个字符，截取
                                tempName = tempName.slice(0, 5);
                            }
                            
                            newName = tempName;
                            playerNicknames[player] = newName;
                            
                            // 保存昵称到存储
                            await kvStorage.set('mahjongNicknames', playerNicknames);
                            

                            
                            // 显示成功提示
                            showToast(`已修改为：${newName}`);
                        }
                        
                        // 恢复显示元素
                        trigger.textContent = newName;
                        parent.insertBefore(trigger, input);
                        parent.removeChild(input);
                        
                        // 同步所有位置的玩家名称
                        updateAllPlayerNames();
                        
                        // 重置编辑状态
                        isEditing = false;
                    };
                    
                    // 失去焦点完成编辑
                    const blurHandler = () => finishEditing(true);
                    
                    // 键盘事件处理
                    const keydownHandler = (e) => {
                        // 按Enter完成编辑
                        if (e.key === 'Enter') {
                            finishEditing(true);
                        }
                        // 按ESC取消编辑
                        if (e.key === 'Escape') {
                            finishEditing(false);
                        }
                    };
                    
                    input.addEventListener('blur', blurHandler);
                    input.addEventListener('keydown', keydownHandler);
                }
            });
        });
        
        // 事件监听器 - 历史记录按钮
        historyBtn.addEventListener('click', () => {
            historyModal.classList.remove('hidden');
        });
        
        // 事件监听器 - 关闭历史记录模态框
        closeModal.addEventListener('click', () => {
            historyModal.classList.add('hidden');
        });
        
        // 点击模态框外部关闭
        historyModal.addEventListener('click', (e) => {
            if (e.target === historyModal) {
                historyModal.classList.add('hidden');
            }
        });
        
        // 清空历史记录并重置总分和庄家
        clearHistoryBtn.addEventListener('click', async () => {
            if (confirm('确定要清空所有历史记录并重置总分和庄家吗？此操作不可撤销！')) {
                // 重置总分
                playerTotalScores = {
                    player1: 0,
                    player2: 0,
                    player3: 0,
                    player4: 0
                };
                updateTotalScoresDisplay();
                
                // 重置庄家
                currentBanker = '';
                selectedWinner = null;
                updatePlayerCardState();
                
                // 清空历史记录
                historyRecords = [];
                currentRoundNumber = 0;
                
                // 重置本局分数
                currentRoundScores = {
                    player1: 0,
                    player2: 0,
                    player3: 0,
                    player4: 0
                };
                Object.keys(playerScores).forEach(player => {
                    if (playerScores[player]) {
                        playerScores[player].textContent = '0';
                        playerScores[player].classList.remove('score-positive', 'score-negative', 'score-zero');
                        playerScores[player].classList.add('score-zero');
                    }
                });
                
                // 保存数据到存储
                await saveTotalScoresToStorage();
                await saveBankerToStorage();
                await kvStorage.set('mahjongHistory', historyRecords);
                
                // 更新历史记录显示
                updateHistoryList();
                
                // 隐藏操作按钮
                hideAllActionButtons();
                

                
                showToast('历史记录已清空，总分和庄家已重置');
            }
        });
        
        // 更新历史记录列表（矩阵式）
        function updateHistoryList() {
            if (historyRecords.length === 0) {
                historyRecordsContainer.innerHTML = '<p class="text-gray-500 text-center italic py-8">暂无记录</p>';
                return;
            }
            
            // 创建表格
            let tableHtml = `
                <table class="matrix-scoreboard">
                    <thead>
                        <tr>
                            <th class="round-col">局数/玩家</th>
            `;
            
            // 添加玩家表头 - 固定顺序
            const playerOrder = ['player1', 'player2', 'player3', 'player4'];
            playerOrder.forEach(player => {
                tableHtml += `<th>${playerNicknames[player]}</th>`;
            });
            
            tableHtml += `
                            <th class="note-col">备注</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // 添加总分行（置顶）
            tableHtml += `<tr class="total-row">`;
            tableHtml += `<td class="round-col">总分</td>`;
            
            playerOrder.forEach(player => {
                const total = playerTotalScores[player] || 0;
                let totalClass = 'score-zero';
                
                if (total > 0) {
                    totalClass = 'score-positive';
                } else if (total < 0) {
                    totalClass = 'score-negative';
                }
                
                tableHtml += `<td><span class="${totalClass}">${total}</span></td>`;
            });
            
            tableHtml += `<td class="note-col"></td>`;
            tableHtml += `</tr>`;
            
            // 逆序添加历史记录（最新的在最上面）
            const reversedRecords = [...historyRecords].reverse();
            reversedRecords.forEach(record => {
                let note = '';
                let rowClass = '';
                
                if (record.type === 'round') {
                    note = `胡: ${playerNicknames[record.winner]}`;
                    if (record.banker === record.winner) {
                        note += '<br>（庄胡）';
                    } else {
                        note += `<br>庄: ${playerNicknames[record.banker]}`;
                    }
                    note += `<br>倍率: ${record.baseScore}`;
                } else if (record.type === 'adjustment') {
                    rowClass = 'init-adjust-row';
                    if (record.adjustment.target === 'all') {
                        note = `全体${record.adjustment.value > 0 ? '加' : '减'}${Math.abs(record.adjustment.value)}分`;
                    } else {
                        note = `${playerNicknames[record.adjustment.target]}<br>${record.adjustment.value > 0 ? '加' : '减'}${Math.abs(record.adjustment.value)}分`;
                    }
                } else if (record.type === 'reset') {
                    note = '重置所有玩家<br>总分';
                }
                
                tableHtml += `<tr class="${rowClass}">`;
                tableHtml += `<td class="round-col">${record.round}</td>`;
                
                // 添加每个玩家的分数
                playerOrder.forEach(player => {
                    const score = record.scores[player] || 0;
                    let scoreClass = 'score-zero';
                    let cellClass = rowClass ? 'init-adjust-cell' : '';
                    
                    if (score > 0) {
                        scoreClass = 'score-positive';
                    } else if (score < 0) {
                        scoreClass = 'score-negative';
                    }
                    
                    tableHtml += `<td class="${cellClass}"><span class="${scoreClass}">${score !== 0 ? score : '-'}</span></td>`;
                });
                
                tableHtml += `<td class="note-col"><span class="note-text">${note}</span></td>`;
                tableHtml += `</tr>`;
            });
            
            tableHtml += `
                    </tbody>
                </table>
            `;
            
            historyRecordsContainer.innerHTML = tableHtml;
        }
        
        // 分数调整按钮事件
        applyAdjustBtn.addEventListener('click', async () => {
            await applyScoreAdjustment();
        });
        
        // 按回车应用分数调整
        scoreAdjustValue.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                await applyScoreAdjustment();
            }
        });
        
        // KV存储系统设计
        // 核心接口定义
        class KVStorage {
            constructor(localAdapter, remoteAdapter) {
                this.localAdapter = localAdapter;
                this.remoteAdapter = remoteAdapter;
                this.syncInterval = null;
                this.syncListeners = [];
                this.isSyncing = false;
                this.dataVersion = Date.now();
            }

            // 获取数据
            async get(key) {
                // 优先从本地获取
                const localData = this.localAdapter.get(key);
                if (localData !== null) {
                    return localData;
                }
                
                // 本地没有则从远程获取
                const remoteData = await this.remoteAdapter.get(key);
                if (remoteData !== null) {
                    this.localAdapter.set(key, remoteData);
                }
                return remoteData;
            }

            // 设置数据
            async set(key, value) {
                // 同时更新本地和远程
                this.localAdapter.set(key, value);
                try {
                    await this.remoteAdapter.set(key, value);
                    this.triggerSyncEvent({ key, value, type: 'set' });
                    this.dataVersion = Date.now();
                } catch (error) {
                    console.error('远程存储更新失败:', error);
                    // 远程更新失败不影响本地操作
                }
            }

            // 删除数据
            async remove(key) {
                this.localAdapter.remove(key);
                try {
                    await this.remoteAdapter.remove(key);
                    this.triggerSyncEvent({ key, type: 'remove' });
                    this.dataVersion = Date.now();
                } catch (error) {
                    console.error('远程存储删除失败:', error);
                }
            }

            // 清空所有数据
            async clear() {
                this.localAdapter.clear();
                try {
                    await this.remoteAdapter.clear();
                    this.triggerSyncEvent({ type: 'clear' });
                    this.dataVersion = Date.now();
                } catch (error) {
                    console.error('远程存储清空失败:', error);
                }
            }

            // 手动同步
            async sync() {
                if (this.isSyncing) return;
                this.isSyncing = true;
                
                try {
                    // 获取本地所有键
                    const localKeys = this.localAdapter.getAllKeys();
                    
                    // 同步本地数据到远程
                    for (const key of localKeys) {
                        const localData = this.localAdapter.get(key);
                        await this.remoteAdapter.set(key, localData);
                    }
                    
                    // 获取远程所有键，检查本地是否缺失
                    const remoteKeys = await this.remoteAdapter.getAllKeys();
                    for (const key of remoteKeys) {
                        if (!localKeys.includes(key)) {
                            const remoteData = await this.remoteAdapter.get(key);
                            this.localAdapter.set(key, remoteData);
                        }
                    }
                    
                    this.triggerSyncEvent({ type: 'sync', timestamp: Date.now() });
                    this.dataVersion = Date.now();
                    showToast('数据同步完成');
                } catch (error) {
                    console.error('数据同步失败:', error);
                } finally {
                    this.isSyncing = false;
                }
            }

            // 启动自动同步
            startAutoSync(interval = 30000) { // 默认30秒同步一次
                this.stopAutoSync();
                this.syncInterval = setInterval(() => {
                    this.sync();
                }, interval);
            }

            // 停止自动同步
            stopAutoSync() {
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                    this.syncInterval = null;
                }
            }

            // 注册同步事件监听器
            onSync(callback) {
                this.syncListeners.push(callback);
                return () => {
                    this.syncListeners = this.syncListeners.filter(cb => cb !== callback);
                };
            }

            // 触发同步事件
            triggerSyncEvent(data) {
                this.syncListeners.forEach(callback => {
                    try {
                        callback(data);
                    } catch (error) {
                        console.error('同步事件处理失败:', error);
                    }
                });
            }
        }

        // 本地存储适配器（基于localStorage）
        class LocalStorageAdapter {
            get(key) {
                console.log(`正在读取本地存储键: ${key}`);
                try {
                    // 首先检查localStorage是否可用
                    if (!localStorage) {
                        console.error('localStorage不可用');
                        return null;
                    }
                    
                    const value = localStorage.getItem(key);
                    console.log(`读取到值: ${value}`);
                    
                    if (!value) {
                        console.log(`键 ${key} 不存在或值为空`);
                        return null;
                    }
                    
                    // 对于所有字符串值，先尝试基本类型转换
                    if (typeof value === 'string') {
                        // 尝试转换为数字
                        if (/^\d+$/.test(value)) {
                            console.log(`键 ${key} 的值是数字字符串，转换为数字: ${value}`);
                            return parseInt(value);
                        }
                        
                        // 尝试转换为布尔值
                        if (value === 'true' || value === 'false') {
                            console.log(`键 ${key} 的值是布尔字符串，转换为布尔值: ${value}`);
                            return value === 'true';
                        }
                        
                        // 对于JSON数组或对象，尝试解析
                        if (/^\[|\{/.test(value)) {
                            try {
                                const parsedValue = JSON.parse(value);
                                console.log(`键 ${key} 的值是JSON，解析成功:`, parsedValue);
                                return parsedValue;
                            } catch (jsonError) {
                                console.log(`键 ${key} 的值不是有效的JSON，直接返回原始值:`, value);
                                return value;
                            }
                        }
                        
                        // 其他简单字符串直接返回
                        console.log(`键 ${key} 的值是简单字符串，直接返回:`, value);
                        return value;
                    }
                    
                    // 如果值不是字符串，尝试直接解析
                    try {
                        return JSON.parse(value);
                    } catch (jsonError) {
                        console.log(`键 ${key} 的值无法解析为JSON，直接返回:`, value);
                        return value;
                    }
                } catch (error) {
                    console.error('本地存储读取失败:', error);
                    return null;
                }
            }

            set(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch (error) {
                    console.error('本地存储写入失败:', error);
                    return false;
                }
            }

            remove(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (error) {
                    console.error('本地存储删除失败:', error);
                    return false;
                }
            }

            clear() {
                try {
                    localStorage.clear();
                    return true;
                } catch (error) {
                    console.error('本地存储清空失败:', error);
                    return false;
                }
            }

            getAllKeys() {
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('mahjong')) {
                        keys.push(key);
                    }
                }
                return keys;
            }
        }

        // 远程存储适配器（模拟实现）
        class RemoteStorageAdapter {
            constructor(baseUrl = '/api/kv') {
                this.baseUrl = baseUrl;
                this.mockData = {};
                this.initMockData();
            }

            // 初始化模拟数据
            initMockData() {
                // 模拟一些初始数据
                this.mockData = {
                    'mahjongNicknames': {
                        player1: '玩家1',
                        player2: '玩家2',
                        player3: '玩家3',
                        player4: '玩家4'
                    },
                    'mahjongMultiplier': 1
                };
            }

            // 模拟网络请求延迟
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async get(key) {
                await this.delay(100); // 模拟网络延迟
                
                try {
                    // 实际项目中应该使用fetch API
                    // const response = await fetch(`${this.baseUrl}/${key}`);
                    // if (!response.ok) throw new Error('远程存储读取失败');
                    // return await response.json();
                    
                    // 模拟实现
                    return this.mockData[key] || null;
                } catch (error) {
                    console.error('远程存储读取失败:', error);
                    return null;
                }
            }

            async set(key, value) {
                await this.delay(100); // 模拟网络延迟
                
                try {
                    // 实际项目中应该使用fetch API
                    // const response = await fetch(`${this.baseUrl}/${key}`, {
                    //     method: 'POST',
                    //     headers: {
                    //         'Content-Type': 'application/json'
                    //     },
                    //     body: JSON.stringify(value)
                    // });
                    // if (!response.ok) throw new Error('远程存储写入失败');
                    // return await response.json();
                    
                    // 模拟实现
                    this.mockData[key] = value;
                    return true;
                } catch (error) {
                    console.error('远程存储写入失败:', error);
                    return false;
                }
            }

            async remove(key) {
                await this.delay(100); // 模拟网络延迟
                
                try {
                    // 实际项目中应该使用fetch API
                    // const response = await fetch(`${this.baseUrl}/${key}`, {
                    //     method: 'DELETE'
                    // });
                    // if (!response.ok) throw new Error('远程存储删除失败');
                    // return true;
                    
                    // 模拟实现
                    delete this.mockData[key];
                    return true;
                } catch (error) {
                    console.error('远程存储删除失败:', error);
                    return false;
                }
            }

            async clear() {
                await this.delay(100); // 模拟网络延迟
                
                try {
                    // 实际项目中应该使用fetch API
                    // const response = await fetch(this.baseUrl, {
                    //     method: 'DELETE'
                    // });
                    // if (!response.ok) throw new Error('远程存储清空失败');
                    // return true;
                    
                    // 模拟实现
                    this.mockData = {};
                    return true;
                } catch (error) {
                    console.error('远程存储清空失败:', error);
                    return false;
                }
            }

            async getAllKeys() {
                await this.delay(100); // 模拟网络延迟
                
                try {
                    // 实际项目中应该使用fetch API
                    // const response = await fetch(`${this.baseUrl}/keys`);
                    // if (!response.ok) throw new Error('远程存储获取键列表失败');
                    // return await response.json();
                    
                    // 模拟实现
                    return Object.keys(this.mockData);
                } catch (error) {
                    console.error('远程存储获取键列表失败:', error);
                    return [];
                }
            }
        }

        // 页面加载时初始化
        document.addEventListener('DOMContentLoaded', async () => {
            // 确保toast初始状态正确
            toast.classList.add('hidden');
            
            // 自动检测本地环境并提示用户执行edgeone pages link
            // 初始化KV存储系统
            const localAdapter = new LocalStorageAdapter();
            const remoteAdapter = new RemoteStorageAdapter();
            kvStorage = new KVStorage(localAdapter, remoteAdapter);
            
            // 启动自动同步（30秒间隔）
            kvStorage.startAutoSync(30000);
            
            // 从存储加载数据
            await loadFromStorage();
            
            updateTotalScoresDisplay();
            updatePlayerCardState();
        });
    </script>
</body>
</html>